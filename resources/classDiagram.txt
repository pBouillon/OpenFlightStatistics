@startuml

class Airport {
    {method} + {static} Airport(Int airportId, String airportName, String cityName, String countryName, Double latitude, Double longitude)
    {method} + {static} apply(Int airportId, String airportName, String cityName, String countryName, Double latitude, Double longitude) : Airport
    {method} + {static} unapply(airport: Airport): Option[(Int, String, String, String, Double, Double)]

    {field} + airportId : Int
    {field} + airportName : String
    {field} + cityName : String
    {field} + countryName : String
    {field} + latitude : Double
    {field} + longitude : Double
}

HasCoordinates <|.. Airport

class AirportDatabase {
    {method} - {static} AirportDatabase(Map[Int, Airport] airportIdToAirport)
    {method} + {static} loadFromCSV(File inputFile) : AirportDatabase
    {method} + {static} fromList(List[Airport] airports) : AirportDatabase

    {field} + airportIdToAirport : Map[Int, Airport]

    {method} + getAirportById(Int airportId) : Airport
    {method} + apply(Int airportId) : Airport
    {method} + contains(Int airportId) : Boolean
    {method} + contains(Airport airport) : Boolean
    {method} + getSubset(AirportFilter filter) : AirportDatabase
    {method} + getDistanceMap : AirportDistanceMap
    {method} + toList : List[Airport]
    {method} + getDensityIn(Country country, Function[Country, Double] againstWhat) : Double
    {method} + toStringFull: String
}

AirportDatabase o-- Airport
AirportDatabase --> Airport
AirportDatabase --> AirportDatabase
AirportDatabase --> Country

class AirportDistanceMap {
    {field} + {static} EmptyMapSoNoValue : Double

    {method} + {static} AirportDistanceMap(AirportDatabase)

    {field} - airportDatabase : AirportDatabase
    {field} - airportIdToAirport : Map[Int, Airport]
    {field} - airportIdsToDistance : Map[(Int, Int), Double]
    {field} - airportToAirportId : Map[Airport, Int]
    {field} - pairsNumber : Int
    {field} - sortedDistances : List[Double]

    {method} + containsPairs : Boolean
    {method} + minDistance : Double
    {method} + maxDistance : Double
    {method} + avgDistance : Double
    {method} + medianDistance : Double
    {method} + stdDev : Double
    {method} + apply(Int airportIdA, Int airportIdB) : Double
    {method} + apply (Airport airportA, Airport airportB) : Double
    {method} + getDistanceBetween(Int airportIdA, Int airportIdB) : Double
    {method} + getDistanceBetween(Airport, Airport) : Double
}

AirportDistanceMap *-- AirportDatabase
AirportDistanceMap --> Airport

class Country {
    {method} + {static} Country(String countryName, Long inhabitants, Double surface)
    {method} + {static} apply(String countryName, Long inhabitants, Double surface) : Country
    {method} + {static} unapply(country: Country) : Option[(String, Long, Double)]

    + {field} countryName : String
    + {field} inhabitants : Long
    + {field} surface : Double
}

class CountryDatabase {
    {method} - {static} CountryDatabase(Map[String, Country] countryNameToCountry)
    {method} + {static} loadFromCSV(File inputFile) : CountryDatabase
    {method} + {static} fromList(List[Country] countries) : CountryDatabase

    {field} + countryNameToCountry : Map[String, Country]

    + {method} getCountryByName(String countryName) : Country
    + {method} apply(String countryName) : Country
    + {method} contains(String countryName) : Boolean
    + {method} contains(Country country) : Boolean
    + {method} toList : List[Country]
    + {method} toStringFull : String
}

CountryDatabase *-- Country
CountryDatabase --> Country

abstract class AirportFilter {
    {method} + {static} fancyWrap(String constraintsRepr) : String

    {method} + {abstract} constraintsRepr : String
    {method} + {abstract} accepts(Airport candidate) : Boolean

    {method} + rejects(Airport candidate) : Boolean
    {method} + unary_! : AirportFilter
    {method} + ||(AirportFilter that) : AirportFilter
    {method} + &&(AirportFilter that) : AirportFilter
}

AirportFilter --> Airport

class All << (O,#FF7700) Object >> {
    {method} + accepts(Airport candidate) : Boolean
    {method} + constraintsRepr : String
}

AirportFilter <|-- All
All --> Airport

class Around {
    {method} - {static} Around(Point center, Double radius)
    {method} + {static} apply(HasCoordinates center, Double radius) : Around
    {method} + {static} unapply(Around around) : Option[(Point, Double)]

    {field} + center : Point
    {field} + radius : Double

    {method} + accepts(Airport candidate) : Boolean
    {method} + constraintsRepr : String
}

AirportFilter <|-- Around
Around --> Point
Around --> HasCoordinates
Around --> Airport

class CountryNames{
    {method} + {static} CountryNames(List[String] countryNames)
    {method} + {static} apply(List[String] countryNames) : CountryNames
    {method} + {static} apply(String* countryNames) : CountryNames
    {method} + {static} unapply(CountryNames countryNamesFilter) : Option[List[String]]

    {field} + countryNames: List[String]

    {method} + accepts(Airport candidate) : Boolean
    {method} + constraintsRepr : String
}

AirportFilter <|-- CountryNames
CountryNames --> Airport

enum HemisphereChoice {
    Northern
    Southern
}

class Hemisphere {
    {method} + {static} Hemisphere(HemisphereChoice choice)
    {method} + {static} apply(HemisphereChoice choice): Hemisphere
    {method} + {static} unapply(Hemisphere hemisphereFilter) : Option[HemisphereChoice]

    {field} + choice : HemisphereChoice

    {method} + accepts(Airport candidate) : Boolean
    {method} + constraintsRepr : String
}

AirportFilter <|-- Hemisphere
Hemisphere --> HemisphereChoice
Hemisphere *-- HemisphereChoice
Hemisphere --> Airport

class Window {
    {method} - {static} Window(Point bottomLeft, Point topRight)
    {method} + {static} apply(HasCoordinates coordA, HasCoordinates coordB) : Window
    {method} + {static} unapply(Window windowFilter) : Option[(Point, Point)]

    {field} + bottomLeft : Point
    {field} + topRight : Point

    {method} + accepts(Airport candidate) : Boolean
    {method} + constraintsRepr : String
}

AirportFilter <|-- Window
Window --> Point
Window --> HasCoordinates
Window *-- Point
Window --> Airport

interface HasCoordinates {
    {field} + {abstract} latitude : Double
    {field} + {abstract} longitude : Double

    {method} + toPoint : Point
}

HasCoordinates --> Point

class Point {
    {method} + {static} Point (Double latitude, Double longitude)
    {method} + {static} apply(Double latitude, Double longitude) : Point
    {method} + {static} unapply(Point point) : Option[(Double, Double)]

    {field} + latitude : Double
    {field} + longitude : Double
}

HasCoordinates <|.. Point

class Utils {
    {field} + {static} EarthRadius : Double

    {method} + {static} distance (HasCoordinates objA, HasCoordinates objB) : Double
}

Utils --> HasCoordinates

abstract class BackMapProvider {
    {method} + {abstract} provide(Projector projector, Int width) : BufferedImage
}

BackMapProvider --> Projector

class D3BackMapProvider {
    {method} + {static} D3BackMapProvider(String rawApiUrl, Option[String] style, Option[String] customMapJsonDataUrl)

    {field} - style : Option[String]
    {field} - customMapJsonDataUrl : Option[String]
    {field} + apiUrl : String

    {method} + provide(Projector projector, Int width) : BufferedImage
    {method} - requestBuilder(Int width, Int height, Double centerLatitude, Double centerLongitude, Projector projector) : String
}

BackMapProvider <|-- D3BackMapProvider
D3BackMapProvider --> Projector

abstract class Projector {
    {field} + {abstract} center : Point

    {method} + {abstract} name : String
    {method} + {abstract} description : String
    {method} + {abstract} ratioWidthHeight : Double
    {method} + {abstract} projects(HasCoordinates obj, Int width) : ProjectedPoint
}

Projector *-- Point
Projector --> HasCoordinates
Projector --> ProjectedPoint

class EquiRectangularProjector {
    {method} + {static} EquiRectangularProjector(HasCoordinates centerRaw)

    {field} - rotator : Function[HasCoordinates, Point]
    {field} + center : Point
    {field} + name : String
    {field} + description : String
    {field} + ratioWidthHeight : Double
    {method} + projects(HasCoordinates obj, Int width) : ProjectedPoint
}

Projector <|-- EquiRectangularProjector
EquiRectangularProjector *-- Point
EquiRectangularProjector --> HasCoordinates
EquiRectangularProjector --> Point
EquiRectangularProjector --> ProjectedPoint

class EquiRectangularLat0Projector {
    {method} + {static} EquiRectangularLat0Projector(HasCoordinates centerRaw)

    {field} - rotator : Function[HasCoordinates, Point]
    {field} + center : Point
    {field} + name : String
    {field} + description : String
    {field} + ratioWidthHeight : Double
    {method} + projects(HasCoordinates obj, Int width) : ProjectedPoint
}

Projector <|-- EquiRectangularLat0Projector
EquiRectangularLat0Projector *-- Point
EquiRectangularLat0Projector --> HasCoordinates
EquiRectangularLat0Projector --> Point
EquiRectangularLat0Projector --> ProjectedPoint

##############################################################################
##############################################################################
##############################################################################
##############################################################################
STOPPE ICI
##############################################################################
##############################################################################
##############################################################################
##############################################################################

interface Filling {

}

class Filled {

}

class Outline {
    + Outline(width float)
}

abstract class Marker {
    + color : Color
    + filling : Filling
    + shapeFactory (Double x, Double y) : Shape
    + putAt (Graphics2D brush, Double x, Double y)
}

class Rectangle {
    + Rectangle (Color, Filling, Double width, Double height)
    + shapeFactory(Double xC, double yC) : Shape
}

class Round {
    + Round (Color, Filling, Double radius)
    + shapeFactory(Double xC, double yC) : Shape
}

class MapCreator {
    + image : BufferedImage
    + brush : Graphics2D
    + MapCreator(Projector proj, BackMapProvider bmp, Int width)
    + plotObject(HasCoordinates, Marker)
    + saveToFile(outputFile File)
}

abstract class ProjectedPoint {

}
class OutOfMap {
    + toString() : String
}
class OnMap {
    + OnMap(Double x, Double y)
    + toString() : String
}


@enduml
